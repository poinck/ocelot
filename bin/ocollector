#!/bin/bash
#
# ocollector is the multiplexer for ocelot. It has some predefined functions
# to draw elements for the side-panel using `ocelot-dzen`. It furthermore
# defines the order of all elements.
#
#    ^   ^
#  +-------+
#  |  o_O  |
#  |  >.<  |__/
#  +-------+
#
# ocelot by AndrÃ© Klausnitzer, CC0

source ${OCELOT_PATH}bin/outils.sh

# element order
ELEMENT_ORDER=("dayweek" "time" "date" "year" "volume" "brightness" "desktops" "desktop" "window" "load" "health_cpu" "battery" "updates" "net" "memory_ram" "memory_swap" "disk_home" "disk_root" "nolock" "lock")
if [[ -f ~/.ocelotrc ]] ; then
    . ~/.ocelotrc
    if [[ -n "$element_order" ]] ; then
        ELEMENT_ORDER="$element_order"
    fi
fi

# content of elements
declare -a elements

get_type_index() {
    element_type=$1
    index=99

    ii=0
    for element in ${ELEMENT_ORDER[*]} ; do
        if [[ "$element" == "${element_type}" ]] ; then
            index=$ii
            break
        fi
        ii=$(( ii+1 ))
    done

    echo "$index"
}

guess_display_height() {
    current_resolution="$( xrandr -q --verbose | grep "*current" )"
    _tmp1CR=${current_resolution#*x}

    # debug
    #echo "$_tmp1CR"

    current_height=${_tmp1CR%% *}
    echo -n "$current_height"
}

# load user settings, if any
SCALE=1
PANEL_LINE_COUNT=37     # minimum line count
_PLH=23                 # panel line height
_PW=64                  # panel width
if [[ -f ~/.ocelotrc ]] ; then
    . ~/.ocelotrc
    if [[ -n "$scale" ]] ; then
        SCALE="$scale"
    fi
    echo "[DEBUG] scale = $SCALE"
    if [[ -n "$panel_line_count" ]] ; then
        PANEL_LINE_COUNT="$panel_line_count"
    else
        echo "[DEBUG] panel_line_count not set, guessing .."
        display_height=$( guess_display_height )
        PANEL_LINE_COUNT=$(( display_height/_PLH ))
    fi
    PANEL_LINE_COUNT=$(( PANEL_LINE_COUNT/SCALE ))
    echo "[DEBUG] panel_line_count = $PANEL_LINE_COUNT"
fi

# initialize scaling
_FP=$(( 9*SCALE ))      # font pixels
_BP=$(( 4*SCALE ))      # border pixels
_TOP=$_BP
_PW=$(( _PW*SCALE ))
_PLH=$(( _PLH*SCALE ))

format_element() {
    i=0
    graphs=""
    for e in $@ ; do
        if [[ "$i" -eq 1 ]] ; then
            e=${e//_/ }
            label="  $e"
        elif [[ "$i" -eq 2 ]] ; then
            background="^fg(#$e)^r(${_PW}x${_PLH})"
        elif [[ "$(( i%2 ))" -eq 1 ]] ; then
            if [[ "$e" -gt 100 ]] ; then
                e=100
            fi
            graph_height=$(( _PLH*e/100 ))
            graph_startposv=$(( _PLH-graph_height ))
        elif [[ "$(( i%2 ))" -eq 0 ]] ; then
            graph_color="^fg(#$e)"
            if [[ "$i" -eq 4 ]] ; then
                graph_posh=0
            else
                graph_posh=$(( ( ( i-4 )/2 )*_BP ))
            fi
            graphs="${graphs}^ib(1)^pa(${graph_posh};${graph_startposv})${graph_color}^r(${_BP}x${graph_height})"
        fi
        i=$(( i+1 ))
    done
    output="${background}${graphs}^ib(1)^pa(0;${_TOP})${label}"

    echo "$output"
}

# initialize box colors of side-panel elements
pbc="#1c1c1c" # panel background color
titlewindow_set=0

ofifo="/tmp/ocollector.fifo$OCELOT_INSTANCE"
[[ -p $ofifo ]] || mkfifo -m 600 "$ofifo"
tail -f $ofifo | \
while read -r reply ; do
    # parse input from fifo
    replyType=${reply%%:=*} # use first part of reply seperated by :=
    replyContent=${reply#*:=} # use last part of reply seperated by :=
    _tmp1=${replyContent%%;;*} # first
    if [[ -z "$_tmp1" ]] ; then
        _isBox=false
    else
        _box=${replyContent#*;;} # last
        replyContent="$_tmp1"
        boxOutline=${_box%%--*} # first
        boxFill=${_box#*--} # last
        _isBox=true
    fi

    # print out title window (will not be updated again)
    if [[ "$titlewindow_set" -eq 0 ]] ; then
        echo -e "^tw() "
        titlewindow_set=1
    fi

    # print out child window, jump to first line
    echo -e "^p1()"

    # gather reply type of element, get order index and store it's content
    # to elements array
    current_type=${reply%%\ *}
    current_index=$( get_type_index "$current_type" )
    elements[$current_index]=$( format_element $reply )

    # loop over all elements and echo out
    for ei in ${!elements[*]} ; do
        echo "${elements[$ei]}"
    done

    echo "^fg() "  # blank last line to clear old content
done | ocelot-dzen -p -l "$PANEL_LINE_COUNT" -h "${_PLH}" -ta l -w "${_PW}" -fn "monospace:bold:size=${_FP}" -e 'onstart=uncollapse' -bg "$pbc"

